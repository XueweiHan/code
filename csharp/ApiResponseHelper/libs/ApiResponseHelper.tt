<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
// --------------------------------------------------------------
// <copyright file="ApiResponseHelper.cs" company="Microsoft">
//   Copyright (c) Microsoft. All rights reserved.
// </copyright>
//
// <auto-generated>
//   This code was generated by TextTemplatingFileGenerator.
//
//   Changes to this .cs file may cause incorrect behavior and will be lost if the code is regenerated.
//
//   Regenerate methods:
//     method 1: build Widget project from CoreXT or VisualStudio
//
//     method 2: run this command in console: %PACKAGESROOT%\TextTemplateTransformationToolkit.Tools\bin\retail\amd64\TextTransform.exe %SDROOT%\private\frontend\Answers\services\Widget\src\Models\Api\ApiResponseHelper.tt -out %SDROOT%\private\frontend\Answers\services\Widget\src\objd\amd64\ApiResponseHelper.cs
//
//     method 3: in VisualStudio, set the .tt file's property "Custom Tool" to "TextTemplatingFileGenerator"; then VisualStudio will automatically regenerate the .cs when you modify and save the .tt file.
//
//     method 4: in VisualStudio, set the .tt file's property "Custom Tool" to "TextTemplatingFileGenerator"; right click the .tt file in VisualStudio Solution Explorer, select "Run Custom Tool"
//
//   Debug TT file:
//     1. in VisualStudio, set the .tt file's property "Custom Tool" to "TextTemplatingFileGenerator"
//     2. set break point in .tt file.
//     3. right click the .tt file and select "Debug T4 Template"
//
// </auto-generated>
// --------------------------------------------------------------

namespace Microsoft.Search.Frontend.AnswerServices.Widget.Models.Api
{
    using System;
    using System.Linq;

    static class ApiResponseHelper
    {
<#
        var enlistmentRoot = Environment.GetEnvironmentVariable("INETROOT");
        var intermediateOutputPath = Environment.GetEnvironmentVariable("IntermediateOutputPath") ?? @"objd\amd64";

        var configFilePath = Path.Combine(enlistmentRoot, @"private\frontend\Answers\services\Widget\Src\KnowledgeConfig.ini");
        var configLines = File.ReadAllLines(configFilePath);

        var schemasFilePath = Path.Combine(enlistmentRoot, @"private\frontend\ApiSchemas\Interfaces", intermediateOutputPath, @"Microsoft.Search.Frontend.ApiSchemas.Interfaces.dll");
        var assembly = Assembly.ReflectionOnlyLoadFrom(schemasFilePath);
        InitBaseToDerivedsDictionary(assembly);

        var allAutoGenMethodsKeyInConfigFile = configLines.Where(l => l.StartsWith("ApiResponseAutoGenMethod_") && l.Contains("="))
                                                          .Select(l => l.Substring(0, l.IndexOf("=")).Trim())
                                                          .ToList();

        PushIndent(Tab + Tab);
        foreach (var configKey in allAutoGenMethodsKeyInConfigFile)
        {
            var configValue = GetConfigValue(configKey, configLines);
            var configArray = configValue.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
            if (configArray.Length > 1)
            {
                // use regex to read the method signature.
                var match = Regex.Match(configArray[0].Trim(), @"^([A-Za-z0-9_.]+)\s*\.\s*([A-Za-z0-9_]+)\s*\(\s*([A-Za-z0-9_.]+)\s*\)$");
                if (match.Success)
                {
                    // get method name, input type, output type, and json paths
                    var methodName = match.Groups[2].Value;
                    var inputTypeName = match.Groups[1].Value;
                    var outputTypeName = match.Groups[3].Value;
                    var jsonPaths = configArray.Skip(1);

                    // find input/output types from api schema assembly
                    var outputType = assembly.GetTypes().FirstOrDefault(t => t.FullName.EndsWith(outputTypeName, StringComparison.Ordinal));
                    var inputType = assembly.GetTypes().FirstOrDefault(t => t.FullName.EndsWith(inputTypeName, StringComparison.Ordinal));

                    if (inputType != null && outputType != null)
                    {
                        // generate method
                        GenerateMethod(methodName, inputType, outputType, jsonPaths, configKey);
                    }
                    else
                    {
                        WriteLine("#error Wrong type name: {0} in config key: {1}", inputType == null ? inputTypeName : outputTypeName, configKey);
                    }
                }
                else
                {
                    WriteLine("#error Unrecognize method signature: {0} in config key: {1}", configArray[0], configKey);
                }
            }

            if (configKey != allAutoGenMethodsKeyInConfigFile.Last())
            {
                WriteLine("");
            }
        }
        PopIndent();
#>
    }
}
<#+

    string Tab = "    ";
    Dictionary<Type, HashSet<Type>> BaseToDeriveds = new Dictionary<Type, HashSet<Type>>();

    private void GenerateMethod(string methodName, Type inputType, Type outputType, IEnumerable<string> jsonPaths, string configKey)
    {
        var pathRoot = new PathItem() { PropertyTypeFullName = inputType.FullName };
        var result = new Stack<PropertyInfo>();

        foreach (var path in jsonPaths)
        {
            var pathArray = path.Trim().Split('.');

            // DFS to find the C# property path from the json path.
            int pathCount = Search(inputType, pathArray, 0, result, pathRoot);
            if (pathCount == 0)
            {
                WriteLine("#error Json Path is wrong: {0} in config key: {1}", path, configKey);
            }
            else if (pathCount > 1)
            {
                WriteLine("// There are more than one C# path found in the API schema sharing the same json path: {0} in conifg key: {1}", path, configKey);
            }
        }

        // variable name postfix dictionary, make sure we don't generate a duplicate local variable name.
        var variableNamePostfixes = new Dictionary<string, int>();

        var paramterName = ToVariableName(inputType.Name, variableNamePostfixes);
        WriteLine("static public void {0}(this {1} {2}, Func<{3}, {3}> func)", methodName, inputType.FullName, paramterName, outputType.FullName);
        WriteLine("{");
        PushIndent(Tab);
        WriteLine("if ({0} == null)", paramterName);
        WriteLine("{");
        WriteLine("    return;");
        WriteLine("}");
        WriteLine("");

        foreach (var item in pathRoot.NextItems.Values)
        {
            GeneratePath(paramterName, item, variableNamePostfixes);

            if (item != pathRoot.NextItems.Values.Last())
            {
                WriteLine("");
            }
        }

        PopIndent();
        WriteLine("}");
    }

    private void GeneratePath(string objectName, PathItem currentItem, Dictionary<string, int> variableNamePostfixes)
    {
        var propertyName = currentItem.PropertyName;
        var typeFullName = currentItem.PropertyTypeFullName;
        var indentCount = 0;
        var variableName = ToVariableName(propertyName ?? typeFullName, variableNamePostfixes);
        var hasChildren = currentItem.NextItems.Values.Any();

        if (propertyName == null)
        {
            WriteLine("var {0} = {1} as {2};", variableName, objectName, typeFullName);
            WriteLine("if ({0} != null)", variableName);
            WriteLine("{");
            PushIndent(Tab);
            indentCount = 1;
        }
        else if (currentItem.IsList)
        {
            WriteLine("if ({0}.{1} != null)", objectName, propertyName);
            WriteLine("{");
            PushIndent(Tab);
            indentCount = 1;

            if (currentItem.JsonPath != null)
            {
                WriteLine("// {0}", currentItem.JsonPath);
                WriteLine("{0}.{1} = {0}.{1}", objectName, propertyName);
                WriteLine("    .Select({0} => func({0}))", variableName);
                WriteLine("    .OfType<{0}>()", typeFullName);
                WriteLine("    .ToList();");

                if (hasChildren) WriteLine("");
            }

            if (hasChildren)
            {
                WriteLine("foreach (var {0} in {1}.{2}.OfType<{3}>())", variableName, objectName, propertyName, typeFullName);
                WriteLine("{");
                PushIndent(Tab);
                indentCount = 2;
            }
        }
        else
        {
            if (currentItem.JsonPath != null)
            {
                WriteLine("// {0}", currentItem.JsonPath);
                WriteLine("{0}.{1} = func({0}.{1}) as {2};", objectName, propertyName, typeFullName);

                if (hasChildren) WriteLine("");
            }

            if (hasChildren)
            {
                WriteLine("var {0} = {1}.{2} as {3};", variableName, objectName, propertyName, typeFullName);
                WriteLine("if ({0} != null)", variableName);
                WriteLine("{");
                PushIndent(Tab);
                indentCount = 1;
            }
        }

        foreach (var item in currentItem.NextItems.Values)
        {
            GeneratePath(variableName, item, variableNamePostfixes);

            if (item != currentItem.NextItems.Values.Last())
            {
                WriteLine("");
            }
        }

        for (var i = 0; i < indentCount; ++i)
        {
            PopIndent();
            WriteLine("}");
        }
    }

    class PathItem
    {
        public string PropertyName { get; set; }
        public string PropertyTypeFullName { get; set; }
        public bool IsList { get; set; }

        public string JsonPath { get; set; }

        public Dictionary<string, PathItem> NextItems
        {
            get
            {
                if (nextItems == null)
                {
                    nextItems = new Dictionary<string, PathItem>();
                }
                return nextItems;
            }
        }

        private Dictionary<string, PathItem> nextItems;
    }

    private void InitBaseToDerivedsDictionary(Assembly assembly)
    {
        BaseToDeriveds = new Dictionary<Type, HashSet<Type>>();

        // enumerate all interface types in schema assembly
        foreach (var type in assembly.GetTypes().Where(t => t.IsInterface))
        {
            // get all base Interfaces of this Interface type
            foreach (var baseType in type.GetInterfaces())
            {
                // add base type and derived type in to dictionary.
                HashSet<Type> deriveds;
                if (!BaseToDeriveds.TryGetValue(baseType, out deriveds))
                {
                    deriveds = new HashSet<Type>();
                    BaseToDeriveds.Add(baseType, deriveds);
                }

                deriveds.Add(type);
            }
        }
    }

    private void MergePath(Stack<PropertyInfo> result, string[] path, PathItem pathRoot)
    {
        var current = pathRoot;
        PropertyInfo lastPropety = null;
        string key = null;

        foreach (var property in result.Reverse())
        {
            PathItem next;

            if (lastPropety != null)
            {
                var lastPropertyType = lastPropety.PropertyType.IsGenericType ? lastPropety.PropertyType.GetGenericArguments()[0] : lastPropety.PropertyType;
                if (lastPropertyType != property.DeclaringType && !property.DeclaringType.IsAssignableFrom(lastPropertyType))
                {
                    key = lastPropety.Name + "++" + property.DeclaringType.FullName;
                    if (!current.NextItems.TryGetValue(key, out next))
                    {
                        next = new PathItem() { PropertyTypeFullName = property.DeclaringType.FullName };
                        current.NextItems.Add(key, next);
                    }

                    current = next;
                }
            }

            var propertyTypeName = property.PropertyType.IsGenericType ? property.PropertyType.GetGenericArguments()[0].FullName : property.PropertyType.FullName;

            key = property.DeclaringType.FullName + '+' + property.Name + '+' + propertyTypeName;
            if (!current.NextItems.TryGetValue(key, out next))
            {
                next = new PathItem() { PropertyName = property.Name, PropertyTypeFullName = propertyTypeName, IsList = property.PropertyType.IsGenericType };
                current.NextItems.Add(key, next);
            }

            lastPropety = property;
            current = next;
        }

        current.JsonPath = string.Join(".", path);
    }

    private int Search(Type type, string[] path, int level, Stack<PropertyInfo> result, PathItem pathRoot)
    {
        if (level == path.Length)
        {
            MergePath(result, path, pathRoot);
            return 1;
        }

        var propertyName = GetPropertyNameAndType(path[level]).Item1;

        if (type.IsGenericType)
        {
            // assume api schema bond only contains 1 parameter generic types, such as Nullable<T> and IList<T>, then get the type T.
            type = type.GetGenericArguments()[0];
            return Search(type, path, level, result, pathRoot);
        }

        int foundCount = 0;
        // find the property with the same name from all public properties of current type
        var property = GetPublicProperties(type).FirstOrDefault(p => string.Equals(ToCamelCase(p.Name), propertyName, StringComparison.Ordinal));
        if (property != null)
        {
            result.Push(property);
            foundCount += Search(property.PropertyType, path, level + 1, result, pathRoot);
            result.Pop();
        }

        // we have to search all derived types properties, because some of the properties may defined on the derived types.
        HashSet<Type> deriveds;
        if (BaseToDeriveds.TryGetValue(type, out deriveds))
        {
            foreach (var derived in deriveds)
            {
                // find the property with the same name from the derived type
                property = derived.GetProperties().FirstOrDefault(p => string.Equals(ToCamelCase(p.Name), propertyName, StringComparison.Ordinal));
                if (property != null)
                {
                    var match = level == 0;
                    if (level > 0)
                    {
                        var typeName = GetPropertyNameAndType(path[level - 1]).Item2;
                        match |= typeName == null || property.DeclaringType.FullName.EndsWith(typeName, StringComparison.Ordinal);
                    }

                    if (match)
                    {
                        result.Push(property);
                        foundCount += Search(property.PropertyType, path, level + 1, result, pathRoot);
                        result.Pop();
                    }
                }
            }
        }

        return foundCount;
    }

    static private Tuple<string, string> GetPropertyNameAndType(string propertyName)
    {
        var match = Regex.Match(propertyName, @"^([A-Za-z0-9_]+)\(([A-Za-z0-9_.]+)\)$");
        if (match.Success)
        {
            return new Tuple<string, string>(match.Groups[1].Value, match.Groups[2].Value);
        }

        return new Tuple<string, string>(propertyName, null);
    }

    static private IEnumerable<PropertyInfo> GetPublicProperties(Type type)
    {
        return type.IsInterface
            ? (new[] { type }).Concat(type.GetInterfaces()).SelectMany(i => i.GetProperties())
            : type.GetProperties();
    }

    static private string ToCamelCase(string word)
    {
        return word.Substring(0, 1).ToLowerInvariant() + word.Substring(1);
    }

    static private string ToVariableName(string name, Dictionary<String, int> variableNamePostfixes)
    {
        name = name.Split('.').Last();
        name = ToCamelCase(Regex.Replace(name, @"^I|\d|_", string.Empty));

        if (variableNamePostfixes.ContainsKey(name))
        {
            return name + (++variableNamePostfixes[name]).ToString();
        }
        else
        {
            variableNamePostfixes[name] = 0;
            return name;
        }
    }

    static private string GetConfigValue(string key, string[] configLines)
    {
        for (int i = 0; i < configLines.Length; ++i)
        {
            var values = configLines[i].Split('=');
            if (values.Length == 2 && string.Equals(values[0].Trim(), key, StringComparison.Ordinal))
            {
                var value = values[1].Trim();

                var strBuilder = new StringBuilder();
                while (value.EndsWith("_") && ++i < configLines.Length)
                {
                    strBuilder.Append(value.Substring(0, value.Length - 1));
                    value = configLines[i].Trim();
                }

                strBuilder.Append(value);

                return strBuilder.ToString();
            }
        }

        return null;
    }

#>